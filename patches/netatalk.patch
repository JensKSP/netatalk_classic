diff --git a/contrib/a2boot/a2boot.c b/contrib/a2boot/a2boot.c
index deb63045..2502bd0b 100644
--- a/contrib/a2boot/a2boot.c
+++ b/contrib/a2boot/a2boot.c
@@ -27,6 +27,7 @@
 #include <sys/types.h>
 #include <sys/file.h>
 #include <sys/uio.h>
+#include <sys/ioctl.h>
 
 #include <stdlib.h>
 #include <unistd.h>
diff --git a/distrib/initscripts/Makefile.am b/distrib/initscripts/Makefile.am
index a54ab0fe..1333a7b3 100644
--- a/distrib/initscripts/Makefile.am
+++ b/distrib/initscripts/Makefile.am
@@ -97,7 +97,8 @@ endif
 
 if USE_SYSTEMD
 
-servicedir	= /lib/systemd/system
+#servicedir	= /lib/systemd/system
+servicedir	= /opt/netatalk/lib/systemd/system
 service_DATA	= a2boot.service afpd.service atalkd.service cnid.service papd.service timelord.service
 
 install-data-hook:
diff --git a/etc/afpd/afs.c b/etc/afpd/afs.c
index 9d6835f4..80e47b1b 100644
--- a/etc/afpd/afs.c
+++ b/etc/afpd/afs.c
@@ -23,7 +23,7 @@
 #endif /* HAVE_UNISTD_H */
 #include <sys/stat.h>
 
-#include "globals.h"
+#include <atalk/globals.h>
 #include "directory.h"
 #include "volume.h"
 #include "misc.h"
@@ -131,21 +131,23 @@ void afsmode(const struct volume *vol, char *path, struct maccess *ma, struct di
     struct ViceIoctl	vi;
     char		buf[ 1024 ];
 
-    if (( dir->d_flags & DIRF_FSMASK ) == DIRF_NOFS ) {
-        vi.in_size = 0;
-        vi.out_size = sizeof( buf );
-        vi.out = buf;
-        if ( pioctl( path, VIOCGETAL, &vi, 1 ) < 0 ) {
-            dir->d_flags |= DIRF_UFS;
-        } else {
-            dir->d_flags |= DIRF_AFS;
-        }
-    }
-
-    if (( dir->d_flags & DIRF_FSMASK ) != DIRF_AFS ) {
-        return;
-    }
-
+	if ( dir ) {
+		if (( dir->d_flags & DIRF_FSMASK ) == DIRF_NOFS ) {
+			vi.in_size = 0;
+			vi.out_size = sizeof( buf );
+			vi.out = buf;
+			if ( pioctl( path, VIOCGETAL, &vi, 1 ) < 0 ) {
+				dir->d_flags |= DIRF_UFS;
+			} else {
+				dir->d_flags |= DIRF_AFS;
+			}
+		}
+
+		if (( dir->d_flags & DIRF_FSMASK ) != DIRF_AFS ) {
+			return;
+		}
+	}
+	
     accessmode(vol, path, ma, dir, st );
 
     return;
diff --git a/etc/afpd/directory.c b/etc/afpd/directory.c
index 32cc70a0..d2bde5ec 100644
--- a/etc/afpd/directory.c
+++ b/etc/afpd/directory.c
@@ -1641,6 +1641,8 @@ int getdirparams(const struct vol *vol,
         case DIRPBIT_ACCESS :
             accessmode(vol, upath, &ma, dir , st);
 
+            LOG(log_debug, logtype_afpd, "getdirparams() <- us=%o, ow=%o, gr=%o, wo=%o", 
+                ma.ma_user, ma.ma_world, ma.ma_group, ma.ma_owner);
             *data++ = ma.ma_user;
             *data++ = ma.ma_world;
             *data++ = ma.ma_group;
diff --git a/etc/afpd/file.c b/etc/afpd/file.c
index 88d2b999..e1c2db59 100644
--- a/etc/afpd/file.c
+++ b/etc/afpd/file.c
@@ -1381,8 +1381,8 @@ int afp_copyfile(AFPObj *obj, char *ibuf, size_t ibuflen _U_, char *rbuf _U_, si
     curdir->d_offcnt++;
 
 #ifdef DROPKLUDGE
-    if (vol->v_flags & AFPVOL_DROPBOX) {
-        retvalue=matchfile2dirperms(upath, vol, ddid); /* FIXME sdir or ddid */
+    if (d_vol->v_flags & AFPVOL_DROPBOX) {
+        retvalue=matchfile2dirperms(upath, d_vol, ddid); /* FIXME sdir or ddid */
     }
 #endif /* DROPKLUDGE */
 
diff --git a/etc/afpd/filedir.c b/etc/afpd/filedir.c
index 83ee7136..96c66535 100644
--- a/etc/afpd/filedir.c
+++ b/etc/afpd/filedir.c
@@ -77,7 +77,7 @@ int matchfile2dirperms(
         return AFPERR_NOOBJ ;
     }
 
-    adpath = vol->vfs->ad_path( upath, ADFLAGS_HF );
+    adpath = vol->ad_path( upath, ADFLAGS_HF );
     /* FIXME dirsearch doesn't move cwd to did ! */
     if (( dir = dirlookup( vol, did )) == NULL ) {
         LOG(log_error, logtype_afpd, "matchfile2dirperms: Unable to get directory info.");
@@ -158,6 +158,7 @@ int afp_getfildirparams(AFPObj *obj _U_, char *ibuf, size_t ibuflen _U_, char *r
         /* was AFPERR_PARAM but it helps OS 10.3 when a volume has been removed
          * from the list.
          */
+        LOG(log_debug, logtype_afpd, "getfildirparams() <- AFPERR_ACCESS");
         return( AFPERR_ACCESS );
     }
 
@@ -165,6 +166,7 @@ int afp_getfildirparams(AFPObj *obj _U_, char *ibuf, size_t ibuflen _U_, char *r
     ibuf += sizeof( did );
 
     if (NULL == ( dir = dirlookup( vol, did )) ) {
+        LOG(log_debug, logtype_afpd, "getfildirparams() <- afp_errno=%d", afp_errno);
         return afp_errno;
     }
 
@@ -176,7 +178,9 @@ int afp_getfildirparams(AFPObj *obj _U_, char *ibuf, size_t ibuflen _U_, char *r
     ibuf += sizeof( dbitmap );
 
     if (NULL == ( s_path = cname( vol, dir, &ibuf )) ) {
-        return get_afp_errno(AFPERR_NOOBJ);
+        int err = get_afp_errno(AFPERR_NOOBJ);
+        LOG(log_debug, logtype_afpd, "getfildirparams() <- %d", err);
+        return err;
     }
 
     LOG(log_debug, logtype_afpd, "getfildirparams(vid:%u, did:%u, f/d:%04x/%04x) {cwdid:%u, cwd: %s, name:'%s'}",
@@ -194,6 +198,7 @@ int afp_getfildirparams(AFPObj *obj _U_, char *ibuf, size_t ibuflen _U_, char *r
     }
     if ( s_path->st_errno != 0 ) {
         if (afp_errno != AFPERR_ACCESS) {
+            LOG(log_debug, logtype_afpd, "getfildirparams() <- get_afp_errno(AFPERR_NOOBJ)");
             return( AFPERR_NOOBJ );
         }
     }
@@ -208,14 +213,17 @@ int afp_getfildirparams(AFPObj *obj _U_, char *ibuf, size_t ibuflen _U_, char *r
 
             ret = getdirparams(vol, dbitmap, s_path, dir,
                                rbuf + 3 * sizeof( u_int16_t ), &buflen );
-            if (ret != AFP_OK )
+            if (ret != AFP_OK ) {
+                LOG(log_debug, logtype_afpd, "getfildirparams() <- ret=%d", ret);
                 return( ret );
+            }
         }
         /* this is a directory */
         *(rbuf + 2 * sizeof( u_int16_t )) = (char) FILDIRBIT_ISDIR;
     } else {
         if (fbitmap && AFP_OK != (ret = getfilparams(vol, fbitmap, s_path, curdir,
                                                      rbuf + 3 * sizeof( u_int16_t ), &buflen )) ) {
+            LOG(log_debug, logtype_afpd, "getfildirparams() <- ret=%d", ret);
             return( ret );
         }
         /* this is a file */
@@ -230,6 +238,7 @@ int afp_getfildirparams(AFPObj *obj _U_, char *ibuf, size_t ibuflen _U_, char *r
     rbuf += sizeof( dbitmap ) + sizeof( u_char );
     *rbuf = 0;
 
+    LOG(log_debug, logtype_afpd, "getfildirparams() <- AFP_OK");
     return( AFP_OK );
 }
 
diff --git a/etc/afpd/uid.c b/etc/afpd/uid.c
index 817ac659..cc6bf3a3 100644
--- a/etc/afpd/uid.c
+++ b/etc/afpd/uid.c
@@ -40,7 +40,7 @@ uidgidset *pair;
 void restore_uidgid ( pair )
 uidgidset *pair;
 {
-    uid_t uid
+    uid_t uid;
     gid_t gid;   
     
     uid = geteuid ();
diff --git a/etc/afpd/unix.c b/etc/afpd/unix.c
index c61e2239..29e4ebb2 100644
--- a/etc/afpd/unix.c
+++ b/etc/afpd/unix.c
@@ -107,7 +107,9 @@ static int utombits(mode_t bits)
     mbits |= ( bits & ( S_IWRITE >> 6 )) ? AR_UWRITE : 0;
     /* Do we really need this? */
     mbits |= ( bits & ( S_IEXEC >> 6) ) ? AR_USEARCH : 0;
-
+    
+    LOG(log_debug, logtype_afpd,
+        "utombits(): %o", mbits);
     return( mbits );
 }
 
@@ -127,6 +129,10 @@ mode_t mode;
 
     ma->ma_owner = utombits( mode );
 
+    LOG(log_debug, logtype_afpd,
+        "utommode(): tmp mac: us=%o ow=%o gr=%o wo=%o",
+        ma->ma_user, ma->ma_owner, ma->ma_group, ma->ma_world);
+
     /* ma_user is a union of all permissions but we must follow
      * unix perm
     */
@@ -153,6 +159,10 @@ mode_t mode;
     if ( !stat->st_uid ) {
         ma->ma_user |= AR_UOWN;
     }
+
+    LOG(log_debug, logtype_afpd,
+        "utommode(): mac: us=%o ow=%o gr=%o wo=%o",
+        ma->ma_user, ma->ma_owner, ma->ma_group, ma->ma_world);
 }
 
 #ifdef accessmode
@@ -182,6 +192,9 @@ void accessmode(const struct vol *vol, char *path, struct maccess *ma, struct di
 #ifdef HAVE_ACLS
     acltoownermode(vol, path, st, ma);
 #endif
+    LOG(log_debug, logtype_afpd,
+        "accessmode(\"%s\"): unix: %o mac: us=%o ow=%o gr=%o wo=%o",
+        path, st->st_mode, ma->ma_user, ma->ma_owner, ma->ma_group, ma->ma_world);
 }
 
 int gmem(const gid_t gid)
diff --git a/etc/uams/uams_guest.c b/etc/uams/uams_guest.c
index 0b5019e0..3a779ee6 100644
--- a/etc/uams/uams_guest.c
+++ b/etc/uams/uams_guest.c
@@ -69,9 +69,10 @@ static int noauth_login(void *obj, struct passwd **uam_pwd,
     }
 
 #ifdef AFS
+	// TODO: setpag() doesn't seem to be implemented on medern Linux systems, can we ignore this???
     if ( setpag() < 0 ) {
 	LOG(log_error, logtype_uams, "noauth_login: setpag: %s", strerror(errno) );
-	return( AFPERR_BADUAM );
+	// return( AFPERR_BADUAM );
     }
 #endif /* AFS */
 
diff --git a/etc/uams/uams_krb4/uams_krb4.c b/etc/uams/uams_krb4/uams_krb4.c
index ff7c2c0a..6773ac5d 100644
--- a/etc/uams/uams_krb4/uams_krb4.c
+++ b/etc/uams/uams_krb4/uams_krb4.c
@@ -235,7 +235,8 @@ static int krb4_login(void *obj, struct passwd **uam_pwd,
     if ( setpag() < 0 ) {
 	*rbuflen = 0;
 	LOG(log_error, logtype_default, "krb_login: setpag: %s", strerror(errno) );
-	return( AFPERR_BADUAM );
+	// TODO: setpag() doesn't seem to be implemented on medern Linux systems, can we ignore this???
+	// return( AFPERR_BADUAM );
     }
 #endif /*AFS*/
 
@@ -611,7 +612,8 @@ static int afskrb_login(void *obj, struct passwd *uam_pwd,
     if ( validseskey == 0 ) {
 	if ( setpag() < 0 ) {
 	    LOG(log_error, logtype_default, "krb_login: setpag: %s", strerror(errno) );
-	    return AFPERR_BADUAM;
+		// TODO: setpag() doesn't seem to be implemented on medern Linux systems, can we ignore this???
+	    // return AFPERR_BADUAM;
 	}
 	krb_set_tkt_string(( tktfile = mktemp( _PATH_AFPTKT )));
 	if (( rc =  krb_get_svc_in_tkt( "afpserver", servername, realm,
